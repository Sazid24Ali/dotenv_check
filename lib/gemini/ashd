// lib/gemini/gemini_service.dart
import 'dart:convert';
import 'dart:io';
import 'dart:math'; // For min function
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:http/http.dart' as http; // Re-import http for direct calls
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';

import '../models/syllabus_analyzer_models.dart';
import '../utils/syllabus_calculator.dart';

class GeminiService {

  static String _cleanJsonMarkdown(String rawResponse) {
    final cleaned = rawResponse.trim();
    if (cleaned.startsWith('```json') && cleaned.endsWith('```')) {
      return cleaned.substring('```json'.length, cleaned.length - '```'.length).trim();
    }
    if (cleaned.startsWith('```') && cleaned.endsWith('```')) {
      return cleaned.substring('```'.length, cleaned.length - '```'.length).trim();
    }
    return cleaned;
  }

  static Future<SyllabusAnalysisResponse?> analyzeSyllabus(String syllabusText) async {
    final apiKey = dotenv.env['GEMINI_API_KEY'];
    if (apiKey == null || apiKey.isEmpty) {
      throw Exception('GEMINI_API_KEY not found in .env. Please add it to your .env file.');
    }

    final endpoint = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=$apiKey';

    // *** REVERTED TO FULL COMPLEX PROMPT - NOW EXPECTING FULL RESPONSE VIA STREAMING ***
    final prompt = """
You are an expert academic syllabus analyzer AI.

Your task is to meticulously parse the following OCR text of a course syllabus.
The OCR text might contain errors, so use your best judgment to interpret the content.

Extract the following information and provide it as a **strictly valid JSON** structure with this hierarchical format:

{
  "is_syllabus": true,
  "total_estimated_time_for_syllabus": 0,
  "course_title": "string",
  "course_code": "string",
  "instructor": "string",
  "semester": "string",
  "year": "integer",
  "learning_objectives": [
    "string"
  ],
  "grading_breakdown": {
    "assignment_type_1": "percentage_or_description"
  },
  "weekly_schedule": [
    {
      "week_number": "integer",
      "topic": "string",
      "subtopics": [
        // recursively nested Topic objects
      ],
      "estimated_time": 0,
      "importance": 3,
      "difficulty": 3,
      "readings": ["string"],
      "assignments": ["string"],
      "web_search_keywords": ["string"],
      "suggested_resources": ["string"]
    }
  ],
  "required_materials": ["string"],
  "important_dates": [
    {"event": "string", "date": "string (YYYY-MM-DD format if possible)"}
  ],
  "contact_information": {
    "email": "string",
    "office_hours": "string",
    "other_details": "string"
  },
  "notes_or_disclaimers": "string"
}

### IMPORTANT INSTRUCTIONS FOR GENERATING JSON:

1.  **Hierarchy Preservation:**
    -   Detect units, topics, and subtopics **strictly based on visual cues**: indentation, bullets, numbered lists, line breaks.
    -   NEVER club multiple concepts or subtopics into one. When in doubt, parse as separate nested subtopics.

2.  **Estimated Time Calculation:**
    -   If the syllabus explicitly states time for a topic (e.g., "(60 mins)", "2 hours"), use that exact numerical value in minutes.
    -   If time is NOT explicitly stated for a topic, you **MUST estimate realistically based on the topic's perceived complexity, depth, and typical university course pacing**.
    -   **CRITICAL: NEVER assign 0 minutes to an estimated_time if it's a valid topic.** If you cannot find an explicit time, you **MUST infer a reasonable positive duration** (e.g., 15, 30, 45, 60, 90, 120 minutes). Choose the smallest reasonable duration if uncertain.
    -   **For EVERY** estimated_time that you infer (i.e., not explicitly stated in the syllabus), you **MUST** include a clear `"time_reasoning"` explaining your logic (e.g., "Estimated 45 minutes based on topic complexity for a standard university course. No explicit time found.").
    -   The `total_estimated_time` for each unit and `total_estimated_time_for_syllabus` should be accurate sums of all child topics/subtopics. (This will be calculated client-side, but it's a good reminder for Gemini).

3.  **Default Values:**
    -   For 'importance' and 'difficulty', use a default of 3 (on a scale of 1-5) if not explicitly specified.
    -   If a field is not found or applicable, use an empty string (""), or 0 (for numbers like `year` if genuinely not found), but do not omit the key if it's part of the structure.

4.  **Output Format:**
    -   Your response MUST be a **plain JSON string**, without any markdown code blocks (e.g., no ```json ```).
    -   Ensure all numeric fields are actual **integers**, not strings.
    -   Ensure boolean fields are `true` or `false`, not "true"/"false".
    -   For list fields like `learning_objectives`, `readings`, `assignments`, `web_search_keywords`, `suggested_resources`, `required_materials`, `important_dates`, **ONLY include them if they have actual content**. If they are empty, OMIT the key entirely instead of including an empty array (`[]`). This will help keep JSON size manageable.
    -   Use consistent field names **exactly** as described in the JSON structure above.

**OCR Syllabus Text to Analyze:**
$syllabusText

""";

    try {
      final request = http.Request('POST', Uri.parse(endpoint));
      request.headers.addAll({'Content-Type': 'application/json'});
      request.body = jsonEncode(body);

      final streamedResponse = await request.send();
      
      // Collect streamed chunks
      final responseBodyChunks = <List<int>>[];
      await for (var chunk in streamedResponse.stream) {
        responseBodyChunks.add(chunk);
      }
      final fullResponseBody = utf8.decode(responseBodyChunks.expand((x) => x).toList());


      if (streamedResponse.statusCode == 200) {
        if (fullResponseBody.isEmpty) {
          print('Gemini API: Response body is empty for status 200.');
          throw Exception('Gemini API: Empty response body received.');
        }

        Map<String, dynamic> jsonResponse;
        try {
          jsonResponse = json.decode(fullResponseBody); // Use full body
        } catch (e) {
          print('Gemini API: Failed to decode response body as JSON. Error: $e');
          print('Gemini API: Received body:\n$fullResponseBody'); // Print full body on decode error
          throw Exception('Gemini API: Invalid JSON received: ${fullResponseBody.substring(0, min(fullResponseBody.length, 200))}...');
        }
        
        final List<dynamic>? candidates = jsonResponse['candidates'];
        if (candidates == null || candidates.isEmpty) {
          print('Gemini API: No candidates found in response.');
          if (jsonResponse['promptFeedback'] != null) {
            print('Gemini API: Prompt Feedback: ${jsonResponse['promptFeedback']}');
            if (jsonResponse['promptFeedback']['safetyRatings'] != null) {
              print('Gemini API: Safety Ratings: ${jsonResponse['promptFeedback']['safetyRatings']}');
              throw Exception('Gemini API: Content potentially blocked due to safety concerns.');
            }
          }
          throw Exception('Gemini API: Response missing expected "candidates" or it is empty.');
        }

        final Map<String, dynamic>? firstCandidate = candidates[0];
        if (firstCandidate == null || firstCandidate['content'] == null || firstCandidate['content']['parts'] == null) {
          print('Gemini API: First candidate or its content/parts is null/malformed.');
          print('Gemini API: First candidate JSON: $firstCandidate');
          throw Exception('Gemini API: Response structure for content missing in first candidate.');
        }

        final List<dynamic>? parts = firstCandidate['content']['parts'];
        if (parts == null || parts.isEmpty) {
          print('Gemini API: Parts list is null or empty in first candidate.');
          throw Exception('Gemini API: Response missing expected "parts" or it is empty.');
        }

        final String? rawGeminiText = parts[0]?['text'];
        String cleanText = ''; // Declare cleanText at a higher scope

        if (rawGeminiText != null && rawGeminiText.isNotEmpty) {
          cleanText = _cleanJsonMarkdown(rawGeminiText); // Assign value here
          
          print('DEBUG: Cleaned JSON from Gemini for parsing:\n$cleanText');

          // --- SAVE RAW RESPONSE TO FILE FOR DEBUGGING ---
          try {
            // Request storage permission
            var status = await Permission.storage.request();
            if (status.isGranted) {
              final directory = await getApplicationDocumentsDirectory();
              final file = File('${directory.path}/gemini_parsed_response_debug.json');
              await file.writeAsString(cleanText);
              print('DEBUG: Gemini parsed response saved to: ${file.path}');
              print('DEBUG: Please inspect this file to see the full JSON output.');
            } else {
              print('DEBUG: Storage permission denied. Cannot save parsed response to file. Please grant permission.');
            }
          } catch (e) {
            print('DEBUG: Error saving parsed response to file: $e');
          }
          // --- END NEW: SAVE RAW RESPONSE TO FILE ---


          final Map<String, dynamic> parsedJson = json.decode(cleanText);
          final SyllabusAnalysisResponse syllabusResponse = SyllabusAnalysisResponse.fromJson(parsedJson);
          
          SyllabusCalculator.calculateAllTotals(syllabusResponse);

          return syllabusResponse;
        } else {
          print('Gemini API returned an empty or null response text part.');
          return null;
        }
      } else {
        print('Gemini API request failed with status: ${streamedResponse.statusCode}'); // Use streamedResponse.statusCode
        print('Response body for failed request: $fullResponseBody'); // Use fullResponseBody
        throw Exception('Failed to analyze syllabus: ${streamedResponse.statusCode} - ${fullResponseBody.substring(0, min(fullResponseBody.length, 200))}...');
      }
    } catch (e) {
      print('Error during Gemini API call: $e');
      rethrow;
    }
  }
}